/*
The following program illustrates the start condition of the TWI.
The program enables the interrupt service by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition.
The Start condition further changes the TWDR to SLA Read and the TWCR is set to resume the transfer

Testing:
    - The NACK was acheived by just the master connected to the slave without the SDA and SLA connected with it which makes the slave return a NACK
    - The ACK from the slave was acheived by a fully connected master slave TWI system 
        The 2 can be differentiated by the number of fast blinks in led 13
    - The ACK/NACK interrupt is not triggered in case of await forever in place of 300ms but the start is triggered
    - When a wrong address is mentioned the NACK is assumed and the assert is called accordingly
*/
#include "wclock.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA=4;
end

spawn async/isr [_TWI_vect] do
{
  switch(TW_STATUS){
    case TW_START:
        // change TW_STATUS to SLA + Read and the interrupt is triggered
        TWDR = (SLA << 1) | TW_READ;// read from slave
        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);// continue transfer
        break;
    
    case TW_MR_SLA_ACK:
        // Data Received with an ACK
        ceu_arduino_assert(0,7);
        break;    

    case TW_MR_SLA_NACK:
        // Data Received with a NACK
        ceu_arduino_assert(0,5);
        break;    
        
    default:
        // a default stop condition in case of an error
        TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);
  }
}
end

{
  TWBR = ((F_CPU / 100000L) - 16) / 2;//set bit rate
}
await 3ms;// wait for init;        ||to do: find if this is necessary||


{
TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);// start condition
}
await 300ms;