/*
The following program illustrates the process of master read using TWI via a ceu API.
The program starts by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition every 300ms.
The Start condition further changes the TWDR to SLA Read and the TWCR is set to resume the transfer.
Further, the api sets the buffer/getData to the value of TWDR.
We will emit PIN 12 to the value of the data received.


Testing:
    - The ACK from the slave was acheived by a fully connected master slave TWI system and the LED connected to pin 12 blinks every 300ms corresponding to the data received.
    - When a wrong address is mentioned or the slave is disconnected the NACK is assumed and the assert is called accordingly.
    - When 300ms is replaced by FOREVER the data is sent only once as expected


Circuit :
    - SDA,SCL lines of both master and slave pulled up by a resistor to 5V.
    - 5V and GND of both master and slave connected respectively to operate both at same voltage
    - an LED connected to the PIN 12 that is set to the data received.
    - The slave can be connected to a switch and send data received on the pin connected tot he switch. Any alternate methods to send data is also fine.

*/
#include "wclock.ceu"
#include "gpio.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA;
end
var int requestmode=-1;// 0 for Write and 1 for Read
var u8 errorcode=1;
/*
errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/

var byte twi_receive_buffer=0;// max buffer length = 1 in this 1 byte example
input  (u8,u8) I2C_REQUEST_DONE;
event none receive;

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_RECEIVE do
    outer.requestmode=1;// Read mode
    {SLA=@address;}
    {TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);} // start condition
    await outer.receive;
    *(buffer) = outer.twi_receive_buffer;
end
spawn async/isr [_TWI_vect] do
    var bool done=false;
    {
        switch(TW_STATUS){
            case TW_START:
                TWDR = (SLA << 1) | 1;//SLA+READ
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE); // continue transfer
                break;
            
            case TW_MR_SLA_ACK:
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE); //get only one byte, send nack
                break;
            
            case TW_MR_DATA_NACK:
                @outer.twi_receive_buffer = TWDR;
                TWCR = (1<<TWINT) | (1<<TWEN)| (1<<TWSTO) | (1<<TWIE);// send stop condition
                @done=1;
                break;
            default:
                @done=1;
                TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);//default case sends stop condition. This case occurs in case of error or a NACK
        }
    }

    if done then
        emit outer.receive;
    end
    emit I2C_REQUEST_DONE(1,outer.errorcode);
end

{TWBR = ((F_CPU / 100000L) - 16) / 2;} // Bit rate formula

loop do
    var byte getData = 0;
    emit I2C_REQUEST_RECEIVE(4,&&getData,1);
    _digitalWrite(12, getData as bool);
    await 300ms; //send start every 300ms
end